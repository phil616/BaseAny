# BaseChinese项目

BaseChinese是一个将中文字符转为二进制的项目，它的目的是通过中文来表示任意二进制数据，与Base64不同的是，BaseChinese以及更加推广的BaseAny是以任意字符为基础的，而中文具有人类可读性，因此是可用用于记忆的。

相比于Base64,BaseChinese有如下优点：
1. 人类可读，便于记忆。
2. 由于中文字符的数量远远大于Base64的字符数量，因此可以用更少的字符来表示同样的二进制数据。
3. 字符表依赖于官方发布的通用规范汉字表，因此具有标准性。

但对于这个项目而言，更多的目的是为了完成我的信息论作业，也是尝试一下发布Python的一些工作流。

## 技术细节

在信息论中，信息是需要载体来表示的，在Base64中，使用64个可打印字符来表示任意二进制数据，每个可打印字符都映射了一个固定的二进制数据，因此，我们可以将任意二进制数据转换为Base64，也可以将Base64转换为二进制数据。

### BACL

在该项目中，使用任意长度的不重复字符表来替代Base64的字符表，这个字符表称之为基本可用字符表，BasicAvailableCharacterList，简称BACL。

BACL有以下几个特性：
1. BACL中的字符不重复。
2. BACL中的字符数量满足PADDING的要求。
3. BACL中的字符需要保障有序。
4. BACL中的字符需要保障可打印。

在BaseChinese这个项目中，使用的是教育部发布的通用规范汉字表的第一级字表。

在任意的BACL中，我们可通过计算来算出BACL能表示的二进制最大长度，即
$$
\log_2{N}\\N = length(BACL)
$$
在BaseChinese中，我们使用的是3500个汉字，因此，我们可以表示的二进制最大长度为$\log_2{3500} \approx 11.78$，即11位二进制数。

但这个值大于11小于12，我们无法用12个二进制去表示它，但是11位又有额外的字符集无法使用，这里使用的是最小兼容原则，即使用11位二进制数来表示。剩余哪些无法表示的字符直接舍去不用。

而11这个值称作BACL的可表示位数，available digits，简称AD。
但不受所有的字符都能够使用，因为任意长度的二进制数据注定了不会是AD的整数倍，即会出现不足AD的情况，这时候我们需要使用padding来填充。

### Padding

在编码实际中，可能出现的情况有如下几种：

1. OFP
例如AD的长度是11，实际的二进制数据在去掉11的整数倍后，可能是1~10位这种不足11位的情况，我们称之为需填充状态，OverForPadding，简称OFP。

2. PFP
正好是11位或11位的整数倍，我们称之为完美填充状态，PerfectForPadding，简称PFP。

对于OFP的情况，我们需要考虑如何填充，即使用额外的，不在11位的字符中填充，很明显，需要一些额外的字符来专门表示填充。

需要注意的是，正如Base64的情况，永远都是在后面进行填充，例如下面的情况：

假设我们的AD是4，那么需要填充的情况有如下几种：

映射表如下:
| 数字 | 二进制 | 映射字符 | 
| ---- | ------ | -------- |
| 0 | 0b0000 |  * |
| 1 | 0b0001 |  A |
| 2 | 0b0010 |  B |
| 3 | 0b0011 |  C |
| 4 | 0b0100 |  D |
| 5 | 0b0101 |  E |
| 6 | 0b0110 |  F |
| 7 | 0b0111 |  G |
| 8 | 0b1000 |  H |
| 9 | 0b1001 |  I |
| 10 | 0b1010 |  J |
| 11 | 0b1011 |  K |
| 12 | 0b1100 |  L |
| 13 | 0b1101 |  M |
| 14 | 0b1110 |  N |
| 15 | 0b1111 |  O |

需要填充的情况

| 数字 | 二进制 | 映射字符|填充字符 | 
| ---- | ------ | --- | -------- |
| 1 | 0b0001 |  A | 不填充 |
| 15 | 0b1111 | O | 不填充 |
| 16 | 0b1000 0 000 | H* | 多三个0 |
| 17 | 0b1000 1 000 | HH | 多三个0 |
| ... | ... | ... | ... |
| 48 | 0b1100 00 00 | L* | 多两个0 |
| 49 | 0b1100 01 00 | LD | 多两个0 |
| ... | ... | ... | ... |
| 64 | 0b1000 100 0| HH | 多一个0 |


48需要在L、*后标注有两个0是补上去的，需要一个额外的数字说明补了2个0，
对于AD为4的情况，需要AD-1个0来补充可能的对齐情况。

因此需要额外的AD-1个符号来表示多出来的0。

这AD-1个字符称之为PaddingChars(PC).

PaddingChars的数量为AvailableDigits-1,因此一个BACL的长度至少是AD+PC。

一个最简单的情况，假设BACL的长度是2，那么可用用一个字符表示0，一个字符表示1，不需要额外的PaddingChars。即使是BACL的长度是3，那么我们也无法使用第三个字符，因为不需要PaddingChars。

但BACL的长度如果为4，虽然我们能得到AvaiableDigits是2，即可用一个字符表示两个二进制位，但没有额外的字符来表示PaddingChars，因为AD此时为2，PC为1，需要一个额外的字符来表示PC，但此时没有额外的字符，因此无法使用。

因此，BACL的长度至少为5，即AD+PC>=5。

在BACL中，我们需要导入一个字符集，计算它的AD，并得出PC的值，如果PC的值加上2的AD次方大于BACL的长度，那么这个字符集是不可用的。

现有如下算法判断一个字符集是否可用：
1. 判断BACL的长度BACL_LENGTH = length(BACL_string)
2. 计算AD = log2(BACL_LENGTH) [向下取整]
3. 计算PC = AD - 1
4. 如果PC + 2^AD > BACL_LENGTH, 则不可用，否则可用。

### Encoder

初始化BACL后，就可以进行编码了，给定一个Bytes序列

1. 将Bytes序列转换为二进制字符串
2. 计算需要补0的数量
3. 从头到尾按照AD的长度进行分割，每个AD长度的二进制字符串转换为数字，然后映射到BACL中的字符
4. 如果需要补0，那么在最后添加PC个字符，然后添加需要补0的数量个字符